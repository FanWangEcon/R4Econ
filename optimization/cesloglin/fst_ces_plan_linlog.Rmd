---
title: "CES log lin formulas working with micro estimates"
output:
  html_document:
    df_print: paged
    number_sections: true
    toc: true
    toc_depth: 2  
  html_notebook:
    number_sections: true
  word_document:
    number_sections: true
  pdf_document:
    number_sections: true
    toc: true
    toc_depth: 2  
urlcolor: blue
---

Back to **[Fan](https://fanwangecon.github.io/)**'s R4Econ Homepage **[Table of Content](https://fanwangecon.github.io/R4Econ/)**

# Outline

There is a dataset with child attributes, nutritional inputs and outputs. Run regression to estimate some input output relationship first. Then generate required inputs for code.

1. Required Input
  + @param df tibble data table including variables using svr names below each row is potentially an individual who will receive alternative allocations
  + @param svr_A_i string name of the A_i variable, dot product of covariates and coefficients
  + @param svr_alpha_i string name of the alpha_i variable, individual specific elasticity information
  + @param svr_beta_i string name of the beta_i variable, relative preference weight for each child
  + @param svr_N_i string name of the vector of existing inputs, based on which to compute aggregate resource
  + @param fl_N_hat float total resource avaible for allocation, if not specific, sum by svr_N_i
  + @param fl_rho float preference for equality for the planner
  + @return a dataframe that expands the df inputs with additional results.
2. The structure assumes some regression has already taken place to generate the i specific variables listed. and

Doing this allows for lagged intereaction that are time specific in an arbitrary way.

# Get Data

```{r Load Packages and Process Data}
# Load Library
rm(list = ls())
library(tidyverse)
library(tidymodels)
library(R4Econ)

# Select Cebu Only
df_hw_cebu_m24 <- df_hgt_wgt %>% filter(S.country == 'Cebu' & svymthRound == 24 & prot > 0 & hgt > 0) %>% drop_na()

# Generate Discrete Version of momEdu
df_hw_cebu_m24 <- df_hw_cebu_m24 %>% 
    mutate(momEduRound = cut(momEdu, 
                             breaks=c(-Inf, 10, Inf), 
                             labels=c("MEduLow","MEduHigh"))) %>%
    mutate(hgt0med = cut(hgt0, 
                             breaks=c(-Inf, 50, Inf), 
                             labels=c("h0low","h0high")))

df_hw_cebu_m24$momEduRound = as.factor(df_hw_cebu_m24$momEduRound)
df_hw_cebu_m24$hgt0med = as.factor(df_hw_cebu_m24$hgt0med)

# Attach
attach(df_hw_cebu_m24)
```

# Regression with Data and Construct Input Arrays

## Linear Regression

```{r Linear Regression}
# Input Matrix
mt_lincv <- model.matrix(~ hgt0 + wgt0)
mt_linht <- model.matrix(~ sex:hgt0med - 1)

# Regress Height At Month 24 on Nutritional Inputs with controls
rs_hgt_prot_lin = lm(hgt ~ prot:mt_linht + mt_lincv - 1)
print(summary(rs_hgt_prot_lin))
rs_hgt_prot_lin_tidy = tidy(rs_hgt_prot_lin)
```

## Log-Linear Regression

```{r Log-Linear Regression}
# Input Matrix
mt_logcv <- model.matrix(~ hgt0 + wgt0)
mt_loght <- model.matrix(~ sex:hgt0med - 1)

# Log and log regression for month 24
rs_hgt_prot_log = lm(log(hgt) ~ log(prot):mt_loght + mt_logcv - 1)
print(summary(rs_hgt_prot_log))
rs_hgt_prot_log_tidy = tidy(rs_hgt_prot_log)
```

## Construct Input Arrays $A_i$ and $\alpha_i$

```{r Post Regression Input Processing}

# Generate A_i
ar_Ai_lin <- mt_lincv %*% as.matrix(rs_hgt_prot_lin_tidy %>% filter(!str_detect(term, 'prot')) %>% select(estimate))
ar_Ai_log <- mt_logcv %*% as.matrix(rs_hgt_prot_log_tidy %>% filter(!str_detect(term, 'prot')) %>% select(estimate))

# Generate alpha_i
# Generate A_i
ar_alphai_lin <- mt_linht %*% as.matrix(rs_hgt_prot_lin_tidy %>% filter(str_detect(term, 'prot')) %>% select(estimate))
ar_alphai_log <- mt_loght %*% as.matrix(rs_hgt_prot_log_tidy %>% filter(str_detect(term, 'prot')) %>% select(estimate))

```

# Optimal Allocations

## Common Parameters for Optimal Allocation

```{r Set Allocation Parameters}

# Child Count
df_hw_cebu_m24_full <- df_hw_cebu_m24
it_obs = dim(df_hw_cebu_m24)[1]

ar_rho = c(seq(-200, -100, length.out=5), seq(-100, -25, length.out=5), seq(-25, -5, length.out=5), seq(-5, -1, length.out=5), seq(-1, -0.01, length.out=5), seq(0.01, 0.25, length.out=5), seq(0.25, 0.99, length.out=5))
ar_rho = unique(ar_rho)
```

## Optimal Linear Allocation

```{r Optimal Linear Allocation}

# Optimal Linear Equation
# Planner Inputs
mt_hev_lin = matrix(, nrow = length(ar_rho), ncol = 2)

for (it_rho_ctr in seq(1,length(ar_rho))) {
  rho = ar_rho[it_rho_ctr]
  fl_N_hat = sum(df_hw_cebu_m24$prot)
  
  ar_term_b = ar_Ai_lin*(ar_alphai_lin*(1/(rho - 1)))
  ar_term_c = ar_Ai_lin*(ar_alphai_lin*(1/(rho - 1)))
  ar_term_d = (ar_alphai_lin*(rho/(rho - 1)))
  
  # Child Specific Optimal Allocation Array to Store
  ar_opti_lin = matrix(, nrow = it_obs, ncol = 1)
  for (m in seq(1:it_obs)) {
    fl_topright_q = sum((ar_term_b[m] - ar_term_c)/ar_term_d)
    fl_bottom_q = sum((ar_alphai_lin[m]/ar_alphai_lin)^(rho/(rho-1)))
    fl_opti_q = (fl_N_hat - fl_topright_q)/fl_bottom_q
    ar_opti_lin[m] = fl_opti_q
  }
  
  # Min and Max
  ar_opti_lin = pmin(fl_N_hat, pmax(0, ar_opti_lin))
  df_hw_cebu_m24_full = cbind(df_hw_cebu_m24_full, ar_opti_lin)
  
  # Utilities
  fl_v_data_lin = sum((ar_Ai_lin + prot*ar_alphai_lin - 70)^rho)^(1/rho)
  fl_v_opti_lin = sum((ar_Ai_lin + ar_opti_lin*ar_alphai_lin - 70)^rho)^(1/rho)
  
  ## HEV
  fl_hev = (fl_v_opti_lin/fl_v_data_lin - 1)
  mt_hev_lin[it_rho_ctr,1] = rho;
  mt_hev_lin[it_rho_ctr,2] = fl_hev;
}

tb_hev_lin <- as_tibble(mt_hev_lin) %>% mutate(id = row_number())

lineplot_lin <- tb_hev_lin %>%
    ggplot(aes(x=id, y=V2)) +
        geom_line() +
        geom_point() +
        labs(title = 'HEV and Preference',
             x = 'pref',
             y = 'HEV',
             caption = 'Linear') +
        scale_x_continuous(labels = as.character(tb_hev$V1),
                           breaks = tb_hev$V1)
print(lineplot_lin)

```

## Optimal LogLinear Allocation

```{r Optimal Loglinear Allocation}

mt_hev_log = matrix(, nrow = length(ar_rho), ncol = 2)

for (it_rho_ctr in seq(1,length(ar_rho))) {
  rho = ar_rho[it_rho_ctr]
  fl_N_hat = sum(df_hw_cebu_m24$prot)
  
  ar_term_b = ar_Ai_lin*(ar_alphai_lin*(1/(rho - 1)))
  ar_term_c = ar_Ai_lin*(ar_alphai_lin*(1/(rho - 1)))
  ar_term_d = (ar_alphai_lin*(rho/(rho - 1)))
  
  # Child Specific Optimal Allocation Array to Store
  ar_opti_lin = matrix(, nrow = it_obs, ncol = 1)
  for (m in seq(1:it_obs)) {
    fl_topright_q = sum((ar_term_b[m] - ar_term_c)/ar_term_d)
    fl_bottom_q = sum((ar_alphai_lin[m]/ar_alphai_lin)^(rho/(rho-1)))
    fl_opti_q = (fl_N_hat - fl_topright_q)/fl_bottom_q
    ar_opti_lin[m] = fl_opti_q
  }
  
  # Min and Max
  ar_opti_lin = pmin(fl_N_hat, pmax(0, ar_opti_lin))
  df_hw_cebu_m24_full = cbind(df_hw_cebu_m24_full, ar_opti_lin)
  
  # Utilities
  fl_v_data_lin = sum((ar_Ai_lin + prot*ar_alphai_lin - 70)^rho)^(1/rho)
  fl_v_opti_lin = sum((ar_Ai_lin + ar_opti_lin*ar_alphai_lin - 70)^rho)^(1/rho)
  
  ## HEV
  fl_hev = (fl_v_opti_lin/fl_v_data_lin - 1)
  mt_hev_log[it_rho_ctr,1] = rho;
  mt_hev_log[it_rho_ctr,2] = fl_hev;
}

tb_hev_log <- as_tibble(mt_hev_log) %>% mutate(id = row_number())

lineplot_log <- tb_hev_log %>%
    ggplot(aes(x=id, y=V2)) +
        geom_line() +
        geom_point() +
        labs(title = 'HEV and Preference',
             x = 'pref',
             y = 'HEV',
             caption = 'Linear') +
        scale_x_continuous(labels = as.character(tb_hev$V1),
                           breaks = tb_hev$V1)
print(lineplot_log)

```

