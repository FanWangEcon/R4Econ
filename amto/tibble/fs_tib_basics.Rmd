---
title: "R Examples Generate Tibble Dataframes"
titleshort: "Generate Tibble Dataframes from Matrix and List"
description: |
  Generate tibble data from two dimensional named lists, unlist for exporting.
  Generate tibble dataframe, rename tibble variables, generate tibble row and column names.
  Export tibble table to csv file with date and time stamp in file name.
  Rename numeric sequential columns with string prefix and suffix.
core:
  - package: base
    code: |
      Sys.time()
      format()
      sample(LETTERS, 5, replace = TRUE)
      is.list
  - package: dplyr
    code: |
      as_tibble(mt)
      rename_all(~c(ar_names))
      rename_at(vars(starts_with("xx")), funs(str_replace(., "yy", "yyyy"))
      rename_at(vars(num_range('',ar_it)), funs(paste0(st,.)))
      rowid_to_column()
      row_number()
      min_rank()
      dense_rank()
      mutate_if()
  - package: base
    code: |
      colnames
      rownames
date: 2023-04-11
date_start: 2020-04-01
output:
  pdf_document:
    pandoc_args: '../../_output_kniti_pdf.yaml'
    includes:
      in_header: '../../preamble.tex'
  html_document:
    pandoc_args: '../../_output_kniti_html.yaml'
    includes:
      in_header: "../../hdga.html"
always_allow_html: true
urlcolor: blue
---

<!-- includes:
  in_header: ../../preamble.tex -->

### Generate Dataframe

```{r global_options, include = FALSE}
try(source("../../.Rprofile"))
```

`r text_shared_preamble_one`
`r text_shared_preamble_two`
`r text_shared_preamble_thr`

#### Simple Dataframe, Name Columns

```{r}
# 5 by 3 matrix
mt_rnorm_a <- matrix(rnorm(4,mean=0,sd=1), nrow=5, ncol=3)

# Column Names
ar_st_varnames <- c('id','var1','varb','vartheta')

# Combine to tibble, add name col1, col2, etc.
tb_combine <- as_tibble(mt_rnorm_a) %>%
  rowid_to_column(var = "id") %>%
  rename_all(~c(ar_st_varnames))

# Display
kable(tb_combine) %>% kable_styling_fc()
```

#### Dataframe with Row and Column Names and Export

First, we generate an empty matrix. Second, we compute values to fill in matrix cells.

```{r}
# an NA matrix
it_nrow <- 5
it_ncol <- 3
mt_na <- matrix(NA, nrow=it_nrow, ncol=it_ncol)

# array of nrow values
ar_it_nrow <- seq(1, it_nrow)
ar_it_ncol <- seq(1, it_ncol)

# Generate values in matrix
for (it_row in ar_it_nrow) {
  for (it_col in ar_it_ncol) {
    print(glue::glue("row={it_row} and col={it_col}"))
    mt_na[it_row, it_col] = it_row*it_col + it_row + it_col
  }
}

# Display
kable(mt_na) %>% kable_styling_fc()
```

Third, we label the rows and the columns. Note that we will include the column names as column names, but the row names will be included as a variable.

```{r}
# Column Names
ar_st_col_names <- paste0('colval=', ar_it_ncol) 
ar_st_row_names <- paste0('rowval=', ar_it_nrow) 

# Create tibble, and add in column and row names
tb_row_col_named <- as_tibble(mt_na) %>%
  rename_all(~c(ar_st_col_names)) %>%
  mutate(row_name = ar_st_row_names) %>%
  select(row_name, everything())

# Display
kable(tb_row_col_named) %>% kable_styling_fc()
```

Finally, we generate a file name for exporting this tibble to a CSV file. We create a file name with a time stamp.

```{r}
# Create a file name with date stamp
st_datetime <- base::format(Sys.time(),  "%Y%m%d-%H%M%S")
# Copying a fixed date to avoid generating multiple testing files
# The date string below is generated by Sys.time()
st_snm_filename <- paste0("tibble_out_test_", st_datetime, '.csv')

# Create a file name with the time stamp. 
spn_file_path = file.path(
  "C:", "Users", "fan", 
  "R4Econ", "amto", "tibble", "_file",
  st_snm_filename,
  fsep = .Platform$file.sep)

# Save to file
write_csv(tb_row_col_named, spn_file_path)
```

#### Generate Tibble given Matrixes and Arrays

Given Arrays and Matrixes, Generate Tibble and Name Variables/Columns

- naming tibble columns
- tibble variable names
- dplyr rename tibble
- dplyr rename tibble all variables
- dplyr rename all columns by index
- dplyr tibble add index column
- see also: [SO-51205520](https://stackoverflow.com/questions/45535157/difference-between-dplyrrename-and-dplyrrename-all)

```{r}
# Base Inputs
ar_col <- c(-1,+1)
mt_rnorm_a <- matrix(rnorm(4,mean=0,sd=1), nrow=2, ncol=2)
mt_rnorm_b <- matrix(rnorm(4,mean=0,sd=1), nrow=2, ncol=4)

# Combine Matrix
mt_combine <- cbind(ar_col, mt_rnorm_a, mt_rnorm_b)
colnames(mt_combine) <- c('ar_col',
                          paste0('matcolvar_grpa_', seq(1,dim(mt_rnorm_a)[2])),
                          paste0('matcolvar_grpb_', seq(1,dim(mt_rnorm_b)[2])))

# Variable Names
ar_st_varnames <- c('var_one',
                    paste0('tibcolvar_ga_', c(1,2)),
                    paste0('tibcolvar_gb_', c(1,2,3,4)))

# Combine to tibble, add name col1, col2, etc.
tb_combine <- as_tibble(mt_combine) %>% rename_all(~c(ar_st_varnames))

# Add an index column to the dataframe, ID column
tb_combine <- tb_combine %>% rowid_to_column(var = "ID")

# Change all gb variable names
tb_combine <- tb_combine %>%
                  rename_at(vars(starts_with("tibcolvar_gb_")),
                            funs(str_replace(., "_gb_", "_gbrenamed_")))

# Tibble back to matrix
mt_tb_combine_back <- data.matrix(tb_combine)

# Display
kable(mt_combine) %>% kable_styling_fc_wide()
kable(tb_combine) %>% kable_styling_fc_wide()
kable(mt_tb_combine_back) %>% kable_styling_fc_wide()
```

#### Generate a Table from Lists

We run some function, whose outputs are named list, we store the values of the named list as additional rows into a dataframe whose column names are the names from named list.

First, we generate the function that returns named lists.

```{r}
# Define a function
ffi_list_generator <- function(it_seed=123) {
  set.seed(it_seed)
  fl_abc <- rnorm(1)
  ar_efg <- rnorm(3)
  st_word <- sample(LETTERS, 5, replace = TRUE)
  ls_return <- list("abc" = fl_abc, "efg" = ar_efg, "opq" = st_word)
  return(ls_return)
}
# Run the function
it_seed=123
ls_return <- ffi_list_generator(it_seed) 
print(ls_return)
```

Second, we list of lists by running the function above with different starting seeds. We store results in a [two-dimensional list](https://fanwangecon.github.io/R4Econ/amto/list/htmlpdfr/fs_lst_basics.html#15_Two_Dimensional_Unnamed_List).

```{r}
# Run function once to get length
ls_return_test <- ffi_list_generator(it_seed=123) 
it_list_len <- length(ls_return_test)

# list of list frame
it_list_of_list_len <- 5
ls_ls_return <- vector(mode = "list", length = it_list_of_list_len*it_list_len)
dim(ls_ls_return) <- c(it_list_of_list_len, it_list_len)

# Fill list of list
ar_seeds <- seq(123, 123 + it_list_of_list_len - 1)
it_ctr <- 0
for (it_seed in ar_seeds) {
  print(it_seed)
  it_ctr <- it_ctr + 1
  ls_return <- ffi_list_generator(it_seed) 
  ls_ls_return[it_ctr,] <- ls_return
}

# print 2d list
print(ls_ls_return)
```

Third, we convert the list to a tibble dataframe. Prior to conversion we add names to the 1st and 2nd dimensions of the list. Then we print the results.

```{r}
# get names from named list
ar_st_names <- names(ls_return_test)
dimnames(ls_ls_return)[[2]] <- ar_st_names
dimnames(ls_ls_return)[[1]] <- paste0('seed_', ar_seeds)

# Convert to dataframe
tb_ls_ls_return <- as_tibble(ls_ls_return)

# print
kable(tb_ls_ls_return) %>% kable_styling_fc()
```

Fourth, to export list to csv file, we need to unlist list contents. See also [Create a tibble containing list columns](https://stackoverflow.com/a/48036488/8280804)

```{r}
# Unlist 
tb_unlisted <- tb_ls_ls_return %>%
  rowwise() %>%
  mutate_if(is.list, 
    funs(paste(unlist(.), sep='', collapse=', ')))
# print on screen, can see values
print(tb_unlisted)
```

#### Rename Tibble with Numeric Column Names

After reshaping, often could end up with variable names that are all numeric, intgers for example, how to rename these variables to add a common prefix for example.

```{r}
# Base Inputs
ar_col <- c(-1,+1)
mt_rnorm_c <- matrix(rnorm(4,mean=0,sd=1), nrow=5, ncol=10)
mt_combine <- cbind(ar_col, mt_rnorm_c)

# Variable Names
ar_it_cols_ctr <- seq(1, dim(mt_rnorm_c)[2])
ar_st_varnames <- c('var_one', ar_it_cols_ctr)

# Combine to tibble, add name col1, col2, etc.
tb_combine <- as_tibble(mt_combine) %>% rename_all(~c(ar_st_varnames))

# Add an index column to the dataframe, ID column
tb_combine_ori <- tb_combine %>% rowid_to_column(var = "ID")

# Change all gb variable names
tb_combine <- tb_combine_ori %>%
                  rename_at(
                    vars(num_range('',ar_it_cols_ctr)),
                    funs(paste0("rho", . , 'var'))
                    )

# Display
kable(tb_combine_ori) %>% kable_styling_fc_wide()
kable(tb_combine) %>% kable_styling_fc_wide()
```

#### Tibble Row and Column and Summarize

Show what is in the table: 1, column and row names; 2, contents inside table.

```{r}
tb_iris <- as_tibble(iris)
print(rownames(tb_iris))
colnames(tb_iris)
colnames(tb_iris)
summary(tb_iris)
```

#### Sorting and Rank

##### Sorting

- dplyr arrange desc reverse
- dplyr sort

```{r}
# Sort in Ascending Order
tb_iris %>% select(Species, Sepal.Length, everything()) %>%
  arrange(Species, Sepal.Length) %>% head(10) %>%
  kable() %>% kable_styling_fc()

# Sort in Descending Order
tb_iris %>% select(Species, Sepal.Length, everything()) %>%
  arrange(desc(Species), desc(Sepal.Length)) %>% head(10) %>%
  kable() %>% kable_styling_fc()
```

##### Create a Ranking Variable

We use dplyr's [ranking](https://dplyr.tidyverse.org/reference/ranking.html) functions to generate different types of ranking variables.

The example below demonstrates the differences between the functions [row_number()](https://dplyr.tidyverse.org/reference/ranking.html), [min_rank()](https://dplyr.tidyverse.org/reference/ranking.html), and [dense_rank()](https://dplyr.tidyverse.org/reference/ranking.html).

- *row_number*: Given 10 observations, generates index from 1 to 10, ties are given different ranks.
- *min_rank*: Given 10 observations, generates rank where second-rank ties are both given "silver", and the 4th highest ranked variable not given medal.
- *dense_rank*: Given 10 observations, generates rank where second-rank ties are both given "silver" (2nd rank), and the 4th highest ranked variable is given "bronze" (3rd rank), there are no gaps between ranks.

Note that we have "desc(var_name)" in order to generate the variable based on descending sort of the the "var_name" variable.

```{r}
tb_iris %>%
  select(Species, Sepal.Length) %>% head(10) %>%
  mutate(row_number = row_number(desc(Sepal.Length)),
         min_rank = min_rank(desc(Sepal.Length)),
         dense_rank = dense_rank(desc(Sepal.Length))) %>%
  kable(caption = "Ranking variable") %>% kable_styling_fc()
```

#### REconTools Summarize over Tible

Use R4Econ's summary tool.

```{r}
df_summ_stats <- REconTools::ff_summ_percentiles(tb_iris)
kable(t(df_summ_stats)) %>% kable_styling_fc_wide()
```
